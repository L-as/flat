<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Flat.Tutorial</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Flat.Tutorial.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">flat-0.3.11: Principled and efficient bit-oriented binary serialization.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Flat.Tutorial</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p><a href="https://travis-ci.org/Quid2/flat">Build Status</a>
<a href="http://hackage.haskell.org/package/flat">Hackage version</a></p><p>Haskell implementation of <a href="http://quid2.org/docs/Flat.pdf">Flat</a>, a
principled, portable and efficient binary data format
(<a href="http://quid2.org">specs</a>).</p><h3>How To Use It For Fun and Profit</h3><p><a id="how-to-use-it-for-fun-and-profit"></a></p><p>To (de)serialise a data type, make it an instance of the <code><a href="Flat-Class.html#v:Flat" title="Flat.Class">Flat</a></code> class.</p><p>There is <a href="Generics.html">Generics</a> based support to automatically derive instances of
additional types.</p><p>Let&#8217;s see some code, we need a couple of extensions:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>\
</code></strong></pre><p>Import the Flat library:</p><pre>import Flat
</pre><p>Define a couple of custom data types, deriving Generic and Flat:</p><pre>data Direction = North | South | Center | East | West deriving (Show,Generic,Flat)
BB
data List a = Nil | Cons a (List a) deriving (Show,Generic,Flat)
</pre><p>For encoding, use <code>flat</code>, for decoding, use <code>unflat</code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>unflat . flat $ Cons North (Cons South Nil) :: Decoded (List Direction)
</code></strong>Right (Cons North (Cons South Nil))
</pre><p>For the decoding to work correctly, you will naturally need to know the
type of the serialised data. This is ok for applications that do not
require long-term storage and that do not need to communicate across
independently evolving agents. For those who do, you will need to
supplement <code>flat</code> with something like <a href="https://github.com/Quid2/zm">zm</a>.</p><h4>Define Instances for Abstract/Primitive types</h4><p><a id="define-instances-for-abstractprimitive-types"></a></p><p>A set of primitives are available to define <code>Flat</code> instances for
abstract or primitive types.</p><p>Instances for some common, primitive or abstract data types
(Bool,Words,Int,String,Text,ByteStrings,Tuples, Lists, Sequences, Maps
..) are already defined in
<a href="https://github.com/Quid2/flat/blob/master/src/Data/Flat/Instances.hs">Data.Flat.Instances</a>.</p><h4>Optimal Bit-Encoding</h4><p><a id="optimal-bit-encoding"></a></p><p>A pecularity of Flat is that it uses an optimal bit-encoding rather than
the usual byte-oriented one.</p><p>To see this, let&#8217;s define a pretty printing function: <code>bits</code> encodes a
value as a sequence of bits, <code>prettyShow</code> displays it nicely:</p><pre>p :: Flat a =&gt; a -&gt; String
p = prettyShow . bits</pre><p>Now some encodings:</p><pre>p West
-&gt; &quot;111&quot;</pre><pre>p (Nil::List Direction)
-&gt; &quot;0&quot;</pre><pre>aList = Cons North (Cons South (Cons Center (Cons East (Cons West Nil))))
p aList
-&gt; &quot;10010111 01110111 10&quot;</pre><p>As you can see, <code>aList</code> fits in less than 3 bytes rather than 11 as
would be the case with other Haskell byte oriented serialisation
packages like <code>binary</code> or <code>store</code>.</p><p>For the serialisation to work with byte-oriented devices or storage, we
need to add some padding:</p><pre>f :: Flat a =&gt; a -&gt; String
f = prettyShow . paddedBits</pre><pre>f West
-&gt; &quot;11100001&quot;</pre><pre>f (Nil::List Direction)
-&gt; &quot;00000001&quot;</pre><pre>f $ Cons North (Cons South (Cons Center (Cons East (Cons West Nil))))
-&gt; &quot;10010111 01110111 10000001&quot;</pre><p>The padding is a sequence of 0s terminated by a 1 running till the next
byte boundary (if we are already at a byte boundary it will add an
additional byte of value 1, that&#8217;s unfortunate but there is a good
reason for this, check the <a href="http://quid2.org/docs/Flat.pdf">specs</a>).</p><p>Byte-padding is automatically added by the function <code>flat</code> and removed
by <code>unflat</code>.</p><h3>Performance</h3><p><a id="performance"></a></p><p>For some hard data, see this
<a href="https://github.com/haskell-perf/serialization">comparison of the major haskell serialisation libraries</a>.</p><p>Briefly: * Size: <code>flat</code> produces significantly smaller binaries than all
other libraries (3/4 times usually) * Serialization: <code>store</code>, <code>persist</code>
and <code>flat</code> are faster * Deserialization: <code>store</code>, <code>flat</code>, <code>persist</code> and
<code>cereal</code> are faster * Transfer time (serialisation time + transport time
on the network + deserialisation at the receiving end): <code>flat</code> is
usually faster for all but the highest network speeds</p><h3>Compatibility</h3><p><a id="compatibility"></a></p><h4><a href="https://www.haskell.org/ghc/">GHC</a></h4><p><a id="ghc"></a></p><p>Tested with: * <a href="https://www.haskell.org/ghc/">ghc</a> 7.10.3, 8.0.2, 8.2.2,
8.4.4 and 8.6.3 (x64)</p><p>Should also work with (not recently tested): *
<a href="https://www.haskell.org/ghc/">ghc</a> 7.10.3/LLVM 3.5.2 (Arm7)</p><h4><a href="https://github.com/ghcjs/ghcjs">GHCJS</a></h4><p><a id="ghcjs"></a></p><p>Passes all tests in the <code>flat</code> testsuite, except for those relative to
short bytestrings (Data.ByteString.Short) that are unsupported by
<code>ghcjs</code>.</p><p>Check
<a href="https://github.com/Quid2/flat/blob/master/stack-ghcjs.yaml">stack-ghcjs.yaml</a>
to see with what versions of <code>ghcjs</code> it has been tested.</p><p>If you use a different version of <code>ghcjs</code>, you might want to run the
test suite by setting your compiler in
<a href="https://github.com/Quid2/flat/blob/master/stack-ghcjs.yaml">stack-ghcjs.yaml</a>
and then running:</p><pre>stack test --stack-yaml=stack-ghcjs.yaml</pre><p>NOTE: Versions prior to 0.33 encode <code>Double</code> values incorrectly when
they are not aligned with a byte boundary.</p><p>NOTE: A native
<a href="https://github.com/Quid2/ts">TypeScript/JavaScript version</a> of <code>flat</code>
is under development.</p><h4><a href="https://eta-lang.org/">ETA</a></h4><p><a id="eta"></a></p><p>It builds (with etlas 1.5.0.0 and eta eta-0.8.6b2) but currently fails
the test suite.</p><h3>Installation</h3><p><a id="installation"></a></p><p>Get the latest stable version from
<a href="https://hackage.haskell.org/package/flat">hackage</a>.</p><h3>Known Bugs and Infelicities</h3><p><a id="known-bugs-and-infelicities"></a></p><h4>Longish compilation times</h4><p><a id="longish-compilation-times"></a></p><p>&#8217;flat` relies more than other serialisation libraries on extensive
inlining for its good performance, this unfortunately leads to longer
compilation times.</p><p>If you have many data types or very large ones this might become an
issue.</p><p>A couple of good practices that will eliminate or mitigate this problem
are:</p><ul><li>During development, turn optimisations off (<code>stack --fast</code> or <code>-O0</code>
    in the cabal file).</li><li>Keep your serialisation code in a separate module(s).</li></ul><h4>Data types with more than 512 constructors are currently unsupported</h4><p><a id="data-types-with-more-than-512-constructors-are-currently-unsupported"></a></p><p>See also the
<a href="https://github.com/Quid2/flat/issues">full list of open issues</a>.</p><h3>Acknowledgements</h3><p><a id="acknowledgements"></a></p><p><code>flat</code> reuses ideas and readapts code from various packages, mainly:
<code>store</code>, <code>binary-bits</code> and <code>binary</code> and includes contributions from
Justus Sagem&#252;ller.</p></div></div><div id="interface"></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>