<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Flat.Tutorial</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Flat.Tutorial.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">flat-0.3.11: Principled and efficient bit-oriented binary serialization.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Flat.Tutorial</p></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"></ul></details></div><div id="interface"><h1>Documentation</h1><div class="doc"><p>To (de)serialise a data type, make it an instance of the <code><a href="Flat-Class.html#v:Flat" title="Flat.Class">Flat</a></code> class.</p><p>There is <a href="https://hackage.haskell.org/package/base/docs/GHC-Generics.html">Generics</a> based support to automatically derive a correct instance.</p><p>Let&#8217;s see some code.</p><p>We need a couple of extensions:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XDeriveGeneric -XDeriveAnyClass
</code></strong></pre><p>The <code>Flat</code> library:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Flat
</code></strong></pre><p>And, just for fun, a couple of functions to display an encoded value as a sequence of bits:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Flat.Instances.Test (flatBits,allBits)
</code></strong></pre><p>Define a few custom data types, deriving <code>Generic</code> and <code>Flat</code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data Result = Bad | Good deriving (Show,Generic,Flat)
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data Direction = North | South | Center | East | West deriving (Show,Generic,Flat)
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data List a = Nil | Cons a (List a) deriving (Show,Generic,Flat)
</code></strong></pre></div><div class="doc"><p>Now we can encode a List of Directions using <code><a href="Flat-Run.html#v:flat" title="Flat.Run">flat</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>flat $ Cons North (Cons South Nil)
</code></strong>&quot;\149&quot;
</pre><p>The result is a strict <a href="https://hackage.haskell.org/package/bytestring/docs/Data-ByteString.html">ByteString</a>.</p><p>And decode it back using <code><a href="Flat-Run.html#v:unflat" title="Flat.Run">unflat</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>unflat . flat $ Cons North (Cons South Nil) :: Decoded (List Direction)
</code></strong>Right (Cons North (Cons South Nil))
</pre><p>The result is a <code><a href="Flat.html#v:Decoded" title="Flat">Decoded</a></code> value: <code><a href="../base-4.12.0.0/Data-Either.html#t:Either" title="Data.Either">Either</a></code> a <code><a href="Flat.html#v:DecodeException" title="Flat">DecodeException</a></code> or the actual value.</p><h3>Optimal Bit-Encoding</h3><p><a id="optimal-bit-encoding"></a></p><p>A pecularity of Flat is that it uses an optimal bit-encoding rather than
the usual byte-oriented one.</p><p>One bit is all we need for a <code>Result</code> or for an empty <code>List</code> value:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>flatBits Good
</code></strong>&quot;1&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>flatBits (Nil::List Direction)
</code></strong>&quot;0&quot;
</pre><p>Two or three bits suffice for a <code>Direction</code> value:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>flatBits South
</code></strong>&quot;01&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>flatBits West
</code></strong>&quot;111&quot;
</pre><p>For the serialisation to work with byte-oriented devices or storage, we need to add some padding.</p><p>To do so, rather than encoding a plain value, <code><a href="Flat-Run.html#v:flat" title="Flat.Run">flat</a></code> encodes a <code><a href="Flat-Filler.html#v:PostAligned" title="Flat.Filler">PostAligned</a></code> value, that's to say a value followed by a <code><a href="Flat-Filler.html#v:Filler" title="Flat.Filler">Filler</a></code> that stretches till the next byte boundary.</p><p>In practice, the padding is a, possibly empty, sequence of 0s followed by a 1.</p><p>But .. you don't need to worry about these details as byte-padding is automatically added by the function <code><a href="Flat-Run.html#v:flat" title="Flat.Run">flat</a></code> and removed by <code><a href="Flat-Run.html#v:unflat" title="Flat.Run">unflat</a></code>.</p><p>For example, this encodes as 7 bits:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>flatBits $ Cons North (Cons South Nil)
</code></strong>&quot;1001010&quot;
</pre><p>And, with the added padding of a final &quot;1&quot;, will snugly fit in a single byte:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>allBits $ Cons North (Cons South Nil)
</code></strong>&quot;10010101&quot;
</pre><h3>Pre-defined Instances</h3><p>Flat instances are already defined for relevant types of some common packages: array, base, bytestring, containers, dlist, mono-traversable, text, unordered-containers, vector.</p><p>They are automatically imported by the <a href="Flat.html">Flat</a> module.</p><h2>Compatibility</h2><p><a id="compatibility"></a></p><h3><a href="https://www.haskell.org/ghc/">GHC</a></h3><p><a id="ghc"></a></p><p>Tested with: <a href="https://www.haskell.org/ghc/">ghc</a> 7.10.3, 8.0.2, 8.2.2, 8.4.4, 8.6.5 and 8.8.3 (x64).</p><p>Should also work with (not recently tested): <a href="https://www.haskell.org/ghc/">ghc</a> 7.10.3/LLVM 3.5.2 (Arm7).</p><h3><a href="https://github.com/ghcjs/ghcjs">GHCJS</a></h3><p><a id="ghcjs"></a></p><p>Passes all tests in the <code>flat</code> testsuite, except for those relative to short <a href="https://hackage.haskell.org/package/bytestring/docs/Data-ByteString-Short.html">ByteString</a> that is unsupported by <code>ghcjs</code>.</p><p>Check <a href="https://github.com/Quid2/flat/blob/master/stack-ghcjs.yaml">stack-ghcjs.yaml</a> to see with what versions of <code>ghcjs</code> it has been tested.</p><p>If you use a different version of <code>ghcjs</code>, you might want to run the test suite by setting your compiler in <a href="https://github.com/Quid2/flat/blob/master/stack-ghcjs.yaml">stack-ghcjs.yaml</a>
and then running:</p><pre>stack test --stack-yaml=stack-ghcjs.yaml</pre><p>NOTE: Versions of <code>flat</code> prior to 0.33 encoded <code>Double</code> values incorrectly when they are not aligned with a byte boundary.</p><h3><a href="https://eta-lang.org/">ETA</a></h3><p><a id="eta"></a></p><p>It builds (with etlas 1.5.0.0 and eta eta-0.8.6b2) but currently fails the test suite.</p><p>Support for eta is not currently being actively mantained.</p><h2>Known Bugs and Infelicities</h2><p><a id="known-bugs-and-infelicities"></a></p><h3>Longish compilation times</h3><p>Relies more than other serialisation libraries on extensive inlining for its good performance, this unfortunately leads to longer compilation times.</p><p>If you have many data types or very large ones this might become an issue.</p><p>A couple of good practices that will eliminate or mitigate this problem are:</p><ul><li>During development, turn optimisations off (<code>stack --fast</code> or <code>-O0</code>
    in the cabal file).</li><li>Keep your serialisation code in a separate module(s).</li></ul><h3>Data types with more than 512 constructors are currently unsupported</h3><p>This limit could be easily extended, shout if you need it.</p><h3>Other</h3><p><a href="https://github.com/Quid2/flat/issues">Full list of open issues</a>.</p><h2>Other Stuff You Might Like</h2><h3><a href="https://github.com/Quid2/zm">ZM - Language independent, reproducible, absolute types</a></h3><p>To decode <code>flat</code> encoded data you need to know the type of the serialised data.</p><p>This is ok for applications that do not require long-term storage and that do not operate in open distributed systems.</p><p>For those who do, you might want to supplement <code>flat</code> with something like <a href="https://github.com/Quid2/zm">zm</a>.</p><h3>Ports for other languages</h3><p><a href="https://github.com/Quid2/ts">TypeScript/JavaScript</a> and <a href="https://www.purescript.org/">Purescript</a> ports are under development.</p><p>Get in touch if you would like to help porting <code>Flat</code> to other languages.</p><h2>Acknowledgements</h2><p><a id="acknowledgements"></a></p><p><code>flat</code> reuses ideas and readapts code from various packages, mainly:
<code>store</code>, <code>binary-bits</code> and <code>binary</code> and includes contributions from
Justus Sagem&#252;ller.</p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>